// main.rain file
// 
// This is file for showcasing the syntax of my programming language aka. Rain.
// Syntax is inspired from many languages, heavly Jai, Javascript, C++, and Wren.
//
// Enjoy!

/// Main function, everything starts from here:

main :: () {
    println("Hello world!")

    return 0
}

/// Variables:

// Mutuable variable
x := 5

// Constant
y :: 6

/// Functions:

hello :: (name) {
	println("Hello, ${name}!")
}

// Like in Rust, it's possible to just do for example the calculations of an int, and thats going to be just pasted wherever the function was called, but you must specify return type then:

squared :: (x) -> int {
	x ** 2
}

println("The squared of 5 is: ${squared(5)}") // The squared of 5 is: 25

// You can still do the classic way, using the return keyword:
squared2 :: (x) -> int {
	return x ** 2
}

// Optional arguments need a default value:
squared_by :: (x, y = 2) -> int {
	return x ** y
}

/// Objects:
// **Syntax not decided yet!**

z :: {
	"foo": 1,
	"bar": x
	"baz": this["foo"] + 1 // To get a value from inside from the same object, use `this['value']`
}

// Either this syntax:
z :: object {

}

// or like this:
z :: {

}

/// Structs:

Vector2 :: struct
{
    x: int;
    y: int;
}

a := Vector2 { 6, 5 }

println(a.x) // 6

println(a) // Vector2 { x: 6, y: 5 }

// Functions for structs:

Vector2 : magnitude : () {
	return sqrt(this.x * this.x + this.y * this.y);
}

println(a.magnitude()) // 7.8

/// Threads:

// start a thread like this:
b :: thread {
	while (true) {
		println("space key not clicked!")
	}
}

...

// And check for when to stop the thread:

gl.loop(60, () {
	// check for space key
	gl.isKeyDown("space", () {
		b.stop() // thread stopped
		println("space key clicked!")
	})
});

// You can also check for when to stop the thread a more easier and shorter way:

b :: thread {
	...
}.stop_on(
	gl.isKeyDown("space",
		println("space key clicked!")
		)
)
// stop_on(...) checks every frame if the boolean that was provided is true, and if it is, it stops thread, and gl.isKeyDown(...) runs the function inside itself when it's condition also is true.



/// Comments:

// One line comments

/*
    Multiple line comments
*/

/// Operators:

// `::`:

// Initializator or `::` can be used to create a function, a struct or an constant that like a struct and function can't be modified after creation.

// You can specify the constants' variable type before the second `:`:
x: int : 5

// It's possible to initialize a function inside of a struct by giving it the function name after the first colon (`:`), and after that

StructName : FuncName : () {
	// do something...
}


// `:=`:

// The second initializator (`:=`) also known as walrus operator, creates a modifiable variable:
x := 5

// You can specify the variable type before the `=` operator:
x: int = 5



